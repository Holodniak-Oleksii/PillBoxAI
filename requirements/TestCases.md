# Тест-кейси для PillBoxAI

## 1. UserController - Управління користувачами

### TC-001: Успішна реєстрація нового користувача

**Пріоритет:** Високий  
**Передумови:** 
- Backend сервер запущений
- База даних доступна
- Користувач з таким username ще не існує

**Кроки:**
1. Відправити POST запит на `/auth/register`
2. У тілі запиту передати валідні дані:
   ```json
   {
     "username": "testuser",
     "email": "test@example.com",
     "password": "SecurePass123!"
   }
   ```

**Очікуваний результат:**
- HTTP статус: `201 Created`
- Відповідь містить:
  ```json
  {
    "message": "User registered successfully",
    "user": {
      "id": 1,
      "username": "testuser",
      "email": "test@example.com"
    }
  }
  ```
- Користувач створений в базі даних
- Пароль збережений у хешованому вигляді

**Фактичний результат:**
- ✅ **Тест пройдено успішно**
- HTTP статус: `201 Created` отримано
- Відповідь містить коректну структуру з message, user (id, username, email)
- Користувач успішно створений в базі даних
- Пароль збережено у хешованому вигляді (перевірено в БД)


---

### TC-002: Реєстрація з існуючим username

**Пріоритет:** Високий  
**Передумови:**
- Backend сервер запущений
- Користувач "testuser" вже існує в системі

**Кроки:**
1. Відправити POST запит на `/auth/register`
2. У тілі запиту передати дані з існуючим username:
   ```json
   {
     "username": "testuser",
     "email": "another@example.com",
     "password": "SecurePass123!"
   }
   ```

**Очікуваний результат:**
- HTTP статус: `400 Bad Request` або `409 Conflict`
- Відповідь містить повідомлення про помилку:
  ```json
  {
    "error": "Username already exists"
  }
  ```
- Новий користувач НЕ створений в базі даних

**Фактичний результат:**
- ✅ **Тест пройдено успішно**
- HTTP статус: `409 Conflict` отримано
- Відповідь містить повідомлення про помилку: "Username already exists"
- Новий користувач НЕ створений (підтверджено в БД)
- Система коректно обробляє дублювання username


---

### TC-003: Успішний вхід користувача

**Пріоритет:** Високий  
**Передумови:**
- Користувач "testuser" зареєстрований в системі
- Пароль користувача: "SecurePass123!"

**Кроки:**
1. Відправити POST запит на `/auth/login`
2. У тілі запиту передати валідні credentials:
   ```json
   {
     "username": "testuser",
     "password": "SecurePass123!"
   }
   ```

**Очікуваний результат:**
- HTTP статус: `200 OK`
- Відповідь містить:
  ```json
  {
    "message": "Login successful",
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "user": {
      "id": 1,
      "username": "testuser",
      "email": "test@example.com"
    }
  }
  ```
- JWT токен валідний та містить інформацію про користувача

**Фактичний результат:**
- ✅ **Тест пройдено успішно**
- HTTP статус: `200 OK` отримано
- Отримано валідний JWT токен
- Відповідь містить коректні дані користувача (id, username, email)
- JWT токен успішно використовується для авторизації в наступних запитах


---

## 2. MedkitController - Управління аптечками

### TC-004: Створення нової аптечки

**Пріоритет:** Високий  
**Передумови:**
- Користувач авторизований (є валідний JWT токен)
- ID користувача: 1

**Кроки:**
1. Відправити POST запит на `/api/medkits?ownerId=1`
2. Додати JWT токен в заголовок `Authorization: Bearer {token}`
3. У тілі запиту передати дані аптечки:
   ```json
   {
     "name": "Домашня аптечка",
     "description": "Основна аптечка для дому"
   }
   ```

**Очікуваний результат:**
- HTTP статус: `201 Created`
- Відповідь містить:
  ```json
  {
    "id": 1,
    "name": "Домашня аптечка",
    "description": "Основна аптечка для дому",
    "ownerId": 1,
    "createdAt": "2024-11-19T14:10:00"
  }
  ```
- Аптечка створена в базі даних
- Власник аптечки - користувач з ID 1

**Фактичний результат:**
- ✅ **Тест пройдено успішно**
- HTTP статус: `201 Created` отримано
- Відповідь містить всі поля: id, name, description, ownerId, createdAt
- Аптечка успішно створена в базі даних (підтверджено)
- Власник аптечки коректно встановлений (userId = 1)


---

### TC-005: Пошук аптечок за назвою

**Пріоритет:** Середній  
**Передумови:**
- Користувач авторизований
- В системі існують аптечки:
  - "Домашня аптечка"
  - "Дорожня аптечка"
  - "Офісна аптечка"

**Кроки:**
1. Відправити GET запит на `/api/medkits/search?name=Домашня`
2. Додати JWT токен в заголовок `Authorization`

**Очікуваний результат:**
- HTTP статус: `200 OK`
- Відповідь містить масив з однією аптечкою:
  ```json
  [
    {
      "id": 1,
      "name": "Домашня аптечка",
      "description": "Основна аптечка для дому",
      "ownerId": 1
    }
  ]
  ```
- Повертаються тільки аптечки, що містять "Домашня" в назві

**Фактичний результат:**
- ✅ **Тест пройдено успішно**
- HTTP статус: `200 OK` отримано
- Відповідь містить масив з 1 аптечкою "Домашня аптечка"
- Пошук працює коректно (часткове співпадіння назви)
- Інші аптечки не повертаються


---

### TC-006: Видалення аптечки

**Пріоритет:** Високий  
**Передумови:**
- Користувач авторизований як власник аптечки
- Аптечка з ID 1 існує

**Кроки:**
1. Відправити DELETE запит на `/api/medkits/1`
2. Додати JWT токен в заголовок `Authorization`

**Очікуваний результат:**
- HTTP статус: `204 No Content`
- Тіло відповіді порожнє
- Аптечка видалена з бази даних
- Всі пов'язані ліки також видалені (каскадне видалення)

**Фактичний результат:**
- ✅ **Тест пройдено успішно**
- HTTP статус: `204 No Content` отримано
- Тіло відповіді порожнє (як очікувалось)
- Аптечка успішно видалена з БД (підтверджено)
- Каскадне видалення працює: всі пов'язані ліки також видалені


---

## 3. PillController - Управління ліками

### TC-007: Додавання ліків до аптечки

**Пріоритет:** Високий  
**Передумови:**
- Користувач авторизований (ID: 1)
- Аптечка з ID 1 існує та належить користувачу

**Кроки:**
1. Відправити POST запит на `/api/pills?medkitId=1&createdById=1`
2. Додати JWT токен в заголовок `Authorization`
3. У тілі запиту передати дані ліків:
   ```json
   {
     "name": "Парацетамол",
     "description": "Знеболююче та жарознижуюче",
     "quantity": 20,
     "expiryDate": "2025-12-31",
     "dosage": "500mg"
   }
   ```

**Очікуваний результат:**
- HTTP статус: `201 Created`
- Відповідь містить:
  ```json
  {
    "id": 1,
    "name": "Парацетамол",
    "description": "Знеболююче та жарознижуюче",
    "quantity": 20,
    "expiryDate": "2025-12-31",
    "dosage": "500mg",
    "medkitId": 1,
    "createdById": 1,
    "createdAt": "2024-11-19T14:10:00"
  }
  ```
- Ліки додані до аптечки в базі даних

**Фактичний результат:**
- ✅ **Тест пройдено успішно**
- HTTP статус: `201 Created` отримано
- Відповідь містить всі поля ліків: id, name, description, quantity, expiryDate, dosage, medkitId, createdById, createdAt
- Ліки успішно додані до аптечки в БД
- Зв'язок з аптечкою встановлено коректно


---

### TC-008: Зменшення кількості ліків (прийом)

**Пріоритет:** Високий  
**Передумови:**
- Ліки з ID 1 існують
- Поточна кількість: 20 таблеток
- Користувач авторизований

**Кроки:**
1. Відправити PATCH запит на `/api/pills/1/take?quantity=2`
2. Додати JWT токен в заголовок `Authorization`

**Очікуваний результат:**
- HTTP статус: `200 OK`
- Відповідь містить оновлені дані:
  ```json
  {
    "id": 1,
    "name": "Парацетамол",
    "quantity": 18,
    "...": "..."
  }
  ```
- Кількість ліків зменшена на 2 (20 - 2 = 18)
- Зміни збережені в базі даних

**Фактичний результат:**
- ✅ **Тест пройдено успішно**
- HTTP статус: `200 OK` отримано
- Кількість ліків успішно зменшена: 20 → 18
- Відповідь містить оновлені дані з quantity = 18
- Зміни збережені в базі даних (підтверджено)
- Логіка прийому ліків працює коректно


---

### TC-009: Пошук ліків за назвою

**Пріоритет:** Середній  
**Передумови:**
- Користувач авторизований
- В системі існують ліки:
  - "Парацетамол"
  - "Ібупрофен"
  - "Аспірин"

**Кроки:**
1. Відправити GET запит на `/api/pills/search?name=Пара`
2. Додати JWT токен в заголовок `Authorization`

**Очікуваний результат:**
- HTTP статус: `200 OK`
- Відповідь містить масив з одним елементом:
  ```json
  [
    {
      "id": 1,
      "name": "Парацетамол",
      "description": "Знеболююче та жарознижуюче",
      "quantity": 18,
      "expiryDate": "2025-12-31",
      "dosage": "500mg"
    }
  ]
  ```
- Повертаються тільки ліки, що містять "Пара" в назві
- Пошук не чутливий до регістру

**Фактичний результат:**
- ✅ **Тест пройдено успішно**
- HTTP статус: `200 OK` отримано
- Відповідь містить масив з 1 елементом (Парацетамол)
- Пошук працює коректно за частковою назвою "Пара"
- Пошук не чутливий до регістру (підтверджено)
- Інші ліки не повертаються


---

## 4. MedkitMemberController - Управління членами аптечки

### TC-010: Додавання члена до аптечки

**Пріоритет:** Високий  
**Передумови:**
- Користувач авторизований як власник аптечки (ID: 1)
- Аптечка з ID 1 існує
- Користувач з ID 2 існує в системі

**Кроки:**
1. Відправити POST запит на `/api/medkit-members/medkit/1`
2. Додати JWT токен в заголовок `Authorization`
3. У тілі запиту передати дані:
   ```json
   {
     "userId": 2,
     "role": "VIEWER"
   }
   ```

**Очікуваний результат:**
- HTTP статус: `201 Created`
- Відповідь містить:
  ```json
  {
    "id": 1,
    "medkitId": 1,
    "userId": 2,
    "role": "VIEWER",
    "addedAt": "2024-11-19T14:10:00"
  }
  ```
- Користувач 2 доданий до аптечки з роллю VIEWER
- Користувач 2 може переглядати аптечку

**Фактичний результат:**
- ✅ **Тест пройдено успішно**
- HTTP статус: `201 Created` отримано
- Відповідь містить: id, medkitId, userId, role (VIEWER), addedAt
- Користувач 2 успішно доданий до аптечки з роллю VIEWER
- Зв'язок створено в базі даних (підтверджено)
- Права доступу встановлені коректно


---

### TC-011: Зміна ролі члена аптечки

**Пріоритет:** Середній  
**Передумови:**
- Користувач авторизований як власник аптечки
- Член аптечки з ID 1 існує з роллю VIEWER

**Кроки:**
1. Відправити PUT запит на `/api/medkit-members/1/role?role=EDITOR`
2. Додати JWT токен в заголовок `Authorization`

**Очікуваний результат:**
- HTTP статус: `200 OK`
- Відповідь містить оновлені дані:
  ```json
  {
    "id": 1,
    "medkitId": 1,
    "userId": 2,
    "role": "EDITOR",
    "addedAt": "2024-11-19T14:10:00"
  }
  ```
- Роль змінена з VIEWER на EDITOR
- Користувач 2 тепер може редагувати аптечку

**Фактичний результат:**
- ✅ **Тест пройдено успішно**
- HTTP статус: `200 OK` отримано
- Роль успішно змінена: VIEWER → EDITOR
- Відповідь містить оновлені дані з role = "EDITOR"
- Зміни збережені в базі даних (підтверджено)
- Користувач 2 отримав права редагування аптечки


---

### TC-012: Видалення члена з аптечки

**Пріоритет:** Високий  
**Передумови:**
- Користувач авторизований як власник аптечки
- Член аптечки з ID 1 існує

**Кроки:**
1. Відправити DELETE запит на `/api/medkit-members/1`
2. Додати JWT токен в заголовок `Authorization`

**Очікуваний результат:**
- HTTP статус: `204 No Content`
- Тіло відповіді порожнє
- Член видалений з аптечки
- Користувач 2 більше не має доступу до аптечки 1

**Фактичний результат:**
- ✅ **Тест пройдено успішно**
- HTTP статус: `204 No Content` отримано
- Тіло відповіді порожнє (як очікувалось)
- Член успішно видалений з аптечки (підтверджено в БД)
- Користувач 2 більше не має доступу до аптечки 1


---

## Додаткові тест-кейси безпеки

### TC-013: Спроба доступу без JWT токену

**Пріоритет:** Критичний  
**Передумови:**
- Backend сервер запущений

**Кроки:**
1. Відправити GET запит на `/api/medkits` БЕЗ заголовку `Authorization`

**Очікуваний результат:**
- HTTP статус: `401 Unauthorized`
- Відповідь містить повідомлення про помилку:
  ```json
  {
    "error": "Unauthorized",
    "message": "JWT token is missing or invalid"
  }
  ```
- Доступ до ресурсу заборонений

**Фактичний результат:**
- ✅ **Тест пройдено успішно**
- HTTP статус: `401 Unauthorized` отримано
- Відповідь містить повідомлення про помилку
- Доступ до ресурсу заборонено без JWT токену
- Механізм авторизації працює коректно
- Spring Security захист працює як очікувалось


---

### TC-014: SQL Injection захист

**Пріоритет:** Критичний  
**Передумови:**
- Користувач авторизований

**Кроки:**
1. Відправити GET запит на `/api/pills/search?name=' OR '1'='1`
2. Додати JWT токен в заголовок `Authorization`

**Очікуваний результат:**
- HTTP статус: `200 OK`
- Відповідь містить порожній масив або ліки з назвою "' OR '1'='1" (якщо такі існують)
- SQL injection НЕ виконується
- База даних не пошкоджена
- Всі дані залишаються безпечними

**Фактичний результат:**
- ✅ **Тест пройдено успішно**
- HTTP статус: `200 OK` отримано
- Відповідь містить порожній масив (SQL injection не виконався)
- База даних не пошкоджена (перевірено)
- Всі дані залишились безпечними
- Spring Data JPA запобігає SQL injection за допомогою параметризованих запитів


---

## Тест-кейси продуктивності

### TC-015: Час відповіді основних операцій

**Пріоритет:** Високий  
**Передумови:**
- Система під нормальним навантаженням
- База даних містить до 1000 записів

**Кроки:**
1. Виміряти час відповіді для:
   - GET `/api/medkits` (отримання всіх аптечок)
   - GET `/api/pills/search?name=Пара` (пошук ліків)
   - POST `/api/pills` (створення ліків)

**Очікуваний результат:**
- Час відповіді для всіх основних операцій ≤ 5 секунд
- GET запити: ≤ 2 секунди
- POST запити: ≤ 3 секунди
- Пошук: ≤ 3 секунди

**Фактичний результат:**
- ✅ **Тест пройдено успішно**
- GET `/api/medkits`: ~150ms (в межах норми ≤2s)
- GET `/api/pills/search?name=Пара`: ~180ms (в межах норми ≤3s)
- POST `/api/pills`: ~220ms (в межах норми ≤3s)
- Всі операції виконуються значно швидше за вимогу ≤5 секунд
- Продуктивність відповідає вимогам проекту


---
